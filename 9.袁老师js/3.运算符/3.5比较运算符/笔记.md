# 比较运算符

大小比较： >   <   >=   <=
相等比较： ==  !=  ===  !==

**比较运算符的返回类型：Boolean**

**算术运算符的优先级高于比较运算符**

例：

    console.log(2+3 >= 5);// 结果为 true

## 大小比较

两个字符串比较大小，比较的是字符串的字符编码

例：
    console.log('A' > 'B');//A 为 65，B为66 。结果为false

    console.log('11' > '2');//结果为 false  因为 1的ASCMII码为 49， 2的为 50

## 细节

1. 两个字符串比较大小，比较的是字符串的字符编码。

2. 如果一个不是字符串，并且两个都是原始类型，将它们都转化为数字比较

'1' -> 1
'' -> 0
' ' -> 0
' a' -> NaN
'3.14' -> 3.14
'undefined' -> NaN
'null' -> 0
'{}' -> '[object object]' -> NaN


- NaN与任何数字比较，得到的结果是 false
- Infinity 比任何数字都大
- -Infinity 比任何数字都小，
例如：

    console.log('1' >= 10);// 结果为 false

    console.log('2' > true);//结果为 true

3. 如果其中一个是对象，将对象转换为原始类型，然后，按照规则1或者规则2进行比较

目前，对象转换为原始类型后，是字符串"[Object Object]"

## 相等比较

### == 与 != 相等比较

   ==： 比较两个数据式是否相等
   !=： 比较两个数据式是否不相等

**细节**
1. 两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的地址）

2. 两端的类型不同
    1). null 和 undefined，他们之间相等，和其他原始值类型比较，不相等
        console.log(null == 0);// false

    2). 其他原始类型，比较时先转为数字，在进行比较

    3). NaN与任何数字比较，都为 false，包括自身

    4). Infinity 和 -Infinity，自身与自身相等

    5). 对象比较时，要先转换为原始类型后，再进行比较

    console.log({} == 0);//console.log("[Object Object]" == 0);//'[Object Object]'为NaN

**由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不适应这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较。**

